                                        线程

1 线程的概念
    一个正在运行的函数
    posix线程是一套标准，而不是实现。 link with -pthread
    openmp线程标准
    线程标识:pthread_t  (ps axm   ps ax -L)
    pthread_equal();
    pthread_self();


2 线程的创建
    pthread_create();
    线程的调度取决于调度器的策略
  线程的终止
    3种方式:1）线程从启动例程返回，返回值就是线程的退出码
           2）线程可以被同一进程中的其他线程取消
           3）线程调用pthread_exit()函数
    pthread_join()    相当于  wait();  (收尸)

  栈的清理
    pthread_cleanup_push();
    pthread_cleanup_pop();

  线程的取消选项
    线程取消：pthread_cancel();    // 先cancel 再 join
        取消有两种状态：允许和不允许
            允许取消： 异步cancel、推迟cancel(默认)->推迟至cancel点再响应
                    cancel点： POSIX定义的cancel点，都是可能引发阻塞的系统调用
            pthread_setcancalsate():设置是否允许取消
            pthread_setcancaltype():设置取消方式
            pthread_testcancal():什么都不做，就是一个取消点
  线程分离
    pthread_detach();

3 线程同步
  互斥量:   pthread_mutex_t 
            pthread_mutex_init();
            pthread_mutex_destroy();
            pthread_mutex_lock();
            pthread_mutex_trylock();
            pthread_mutex_unlock(); 

  条件变量： pthread_cond_t 
            pthread_cond_init();
            pthread_cond_destroy();
            pthread_cond_broadcast();
            pthread_cond_signal(); 
            pthread_cond_timedwait();
           
            //; /*enqueue-->unlock-->wait() -->lock*/
            // ; 加入条件变量等待队列 --> 解锁互斥量 --->等待唤醒 ---> 移出等待队列再抢锁 --->判断条件
            pthread_cond_wait();

            条件变量与信号同时使用，在程序被信号异常（如ctrl+c）退出时,调用pthread_cond_destroy()或pthread_cancel()时，会有问题:
              
              请参考mytbf_mt_notify的destroy函数 和 abced_e的alrm_handler函数的解决办法.
            在unload模块中，要cancel创建的线程时：
                    1）如果线程中有pthread_cond_wait()时， 不可以cancel，应该向条件变量控制的值赋予一个退出值，以达到线程退出，再join
                    2）如果线程中只有lock、unlock 时，在lock和unlock之间没有取消点则可以cancel然后join
                        否则，cancel会在取消点cancel，导致没有unlock操作，程序出现问题。 
                                                                --->解决办法： 设置互斥量属性为健壮型  pthread_mutexattr_setrobust()
                                                                              参考relayer.c的解决办法
      
            (对thread的mutex，可以通过方法 pthread_mutexattr_setrobust()来设置健壮性属性

              属性为：PTHREAD_MUTEX_ROBUST

              通过设置锁的上面D 属性，我们就改变了默认的行为。

              当一个锁的owner死掉后，其它线程再去lock这个锁的时候，不会被阻塞，而是通过返回值EOWNERDEAD来报告错误。

              那么你可以根据这个错误来进行处理：首先是应该调用pthread_mutex_consistent函数来恢复该锁的一致性，

              然后调用解锁pthread_mutex_unlock，

              接下来在调用加锁，这样该锁的行为就恢复正常了。


              如果上面这个函数在恢复锁的一致性时候没有成功，那么你只需要调用解锁函数就OK了，然后直接返回，而不要去调用加锁函数。

              那么接下来的线程在调用加锁函数的时候，会得到返回值ENOTRECOVERABLE，

              那么需要你做的就是调用pthread_mutex_destroy来destroy掉该锁，然后重新用锁的属性和锁的初始化函数来重新初始化该锁。


              上面的这些解决死锁方式比较适合在系统中只有一个锁的情况，如果系统的死锁是由于多把锁的资源互相等待而造成的，那么这种解决方式无能为力。。。)

             在调用pthread_cond_destroy()时:
                    1）如果只有主线程有pthread_cond_wait()，那直接清除__wrefs;   // 主线程是消费者
                                      if (0 != tbf->cond.__data.__wrefs)
                                      {
                                          tbf->cond.__data.__wrefs = 0;
                                      }
                                      pthread_cond_destroy(&tbf->cond);
                    2）除主线程外，其余线程还有pthread_cond_wait()，那应该向条件变量控制的值赋予一个退出值，以告知线程，停止操作。再清除__wrefs;
                    3）只有其余线程还有pthread_cond_wait()，那应该向条件变量控制的值赋予一个退出值，以告知线程，停止操作。

            所以最好不要将条件变量与进程信号同时使用，参考abcd_ts.c (主线程是生产者（或者说资源控制者）)的解决方案 

 
 
  信号量：
        互斥量 + 条件变量  作用于同一个控制资源的变量  

  读写锁：
        读锁   ---- 共享锁  
        写锁   ---- 互斥锁

4 线程属性
        pthread_attr_t
      pthread_attr_init();
      pthread_attr_destroy();
      pthread_attr_setstacksize();
       ....
  线程同步的属性
      互斥量属性： pthread_mutexattr_t                  

              pthread_mutexattr_getrobust()、
              pthread_mutexattr_setrobust() - 获取和设置互斥属性对象的健壮性属性

              pthread_mutexattr_init();
              pthread_mutexattr_destroy();
              pthread_mutexattr_getpshared();  //跨进程共享
              pthread_mutexattr_setpshared();

              clone();
 

              // 设置互斥量类型及相应的行为  
              
              /*
              PTHREAD_MUTEX_TIMED_NP,PTHREAD_MUTEX_RECURSIVE_NP,PTHREAD_MUTEX_ERRORCHECK_NP, PTHREAD_MUTEX_ADAPTIVE_NP   
              */
              pthread_mutexattr_gettype();
              pthread_mutexattr_settype();
      
      条件变量属性：pthread_condattr_t
                  pthread_condattr_init();
                  pthread_condattr_destroy();
                  pthread_condattr_getpshared();
                  pthread_condattr_setpshared();
      读写锁属性:


5 重入

  多线程中的IO      (getc_unlocked, getchar_unlocked, putc_unlocked, putchar_unlocked - nonlocking stdio functions)

  线程与信号
    pthread_sigmask();
    sigwait();
    pthread_kill();


  线程与fork


openmp   -----> www.openmp.org
